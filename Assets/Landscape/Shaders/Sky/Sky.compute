#pragma kernel ComputeTransmittance
#pragma kernel ComputeMultiScattering
#pragma kernel ComputeSkyView
#pragma kernel ComputeAmbientSH

#define NUM_THREADS 8
#define SH_SAMPLE_COUNT 64

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Assets/Landscape/ShaderLibrary/Sky/MathHelpers.hlsl"
#include "Assets/Landscape/ShaderLibrary/Sky/Scatterings.hlsl"

RWTexture2D<float4> _TransmittanceLUT;
RWTexture2D<float4> _MultiScatteringLUT;
RWTexture2D<float4> _SkyViewLUT;

TEXTURE2D(_TransmittanceReadonlyLUT);
TEXTURE2D(_MultiScatteringReadonlyLUT);
TEXTURE2D(_SkyViewReadonlyLUT);

SAMPLER(linear_clamp_sampler);

// Ambient SH output buffer: 9 coefficients (L0-L2), each with RGB
RWStructuredBuffer<float4> _AmbientSHCoefficients;

float2 IdToUv(uint2 id, float2 dim)
{
	return (float2(id.x, id.y) + 0.5) / dim;
}

float3 TransmitToAtmosphere(in AtmosphereData atmosphere, float3 p, float3 dir)
{
    Ray ray;
    ray.origin = p;
    ray.direction = dir;
	
    float atmosphereRadius = atmosphere.planet_radius + atmosphere.atmosphere_height;
    float distance = RayHitSphereClosest(ray, float3(0.0, 0.0, 0.0), atmosphereRadius);

    if (distance < 0.0)
    {
        return float3(0.0, 0.0, 0.0);
    }

    float3 p0 = p + distance * dir;

    return Transmit(atmosphere, p, p0);
}

float3 MultiScattering(in AtmosphereData atmosphereData, float3 samplePoint, float3 lightDir,
    TEXTURE2D(lut), SAMPLER(lut_sampler))
{
	float phaseFactor = 1.0 / (4.0 * PI);
	float solidAnglerPerSample = 4.0 * PI / (float) NUM_DIRECTION;

	float3 g2 = 0;
	float3 fMs = 0;

	for (int i = 0; i < NUM_DIRECTION; ++i)
	{
		float3 viewDir = RANDOM_SPHERE_SAMPLES[i];
		Ray viewRay;
		viewRay.origin = samplePoint;
		viewRay.direction = viewDir;
		float distanceToAtmosphere = RayHitSphereClosest(viewRay,
			float3(0.0f, 0.0f, 0.0f), atmosphereData.planet_radius + atmosphereData.atmosphere_height);
		float distanceToPlanet = RayHitSphereClosest(viewRay,
			float3(0.0f, 0.0f, 0.0f), atmosphereData.planet_radius);
		float distance =
			distanceToPlanet > 0.0 ? min(distanceToAtmosphere, distanceToPlanet) : distanceToAtmosphere;
		float ds = distance / (float) NUM_SAMPLE;
		float3 p = samplePoint + (viewDir * ds) * 0.5;
		float3 opticalDepth = (float3) 0;
        
		for (int j = 0; j < NUM_SAMPLE; ++j)
		{
			float h = length(p) - atmosphereData.planet_radius;
			float3 sigmaS = RayleighCoefficient(atmosphereData, h) + MieCoefficient(atmosphereData, h);
			float3 sigmaA = OzoneAbsorption(atmosphereData, h) + MieAbsorption(atmosphereData, h);
			float3 sigmaT = sigmaS + sigmaA;
			opticalDepth += sigmaT * ds;

			float3 t1 = TransmitToAtmosphereLut(atmosphereData, p, lightDir, lut, lut_sampler);
			float3 s = Scattering(atmosphereData, p, lightDir, viewDir);
			float3 t2 = exp(-opticalDepth);

			g2 += t1 * s * t2 * phaseFactor * ds * 1.0;
			fMs += t2 * sigmaS * phaseFactor * ds;

			p += viewDir * ds;
		}
	}

	g2 *= solidAnglerPerSample;
	fMs *= solidAnglerPerSample;

	return g2 * (1.0 / (1.0 - fMs));
}

float3 GetSkyColor(in AtmosphereData atmosphere, float3 viewPos, float3 viewDir, float3 lightDir, float maxDistance)
{
	float3 color = float3(0.0, 0.0, 0.0);
	
	Ray ray;
	ray.origin = viewPos;
	ray.direction = viewDir;
	
	float3 planetCenter = float3(0.0, 0.0, 0.0);
	float atmosphereRadius = atmosphere.planet_radius + atmosphere.atmosphere_height;

	float distanceAtmosphere = RayHitSphereClosest(ray, planetCenter, atmosphereRadius);
	float distancePlanet = RayHitSphereClosest(ray, planetCenter, atmosphere.planet_radius);
	float distance = distanceAtmosphere;

	if (distanceAtmosphere < 0.0)
	{
		return color;
	}

	if (distancePlanet > 0.0)
	{
		distance = min(distanceAtmosphere, distancePlanet);
	}

	if (maxDistance > 0.0)
	{
		distance = min(distance, maxDistance);
	}

	const float ds = distance / float(NUM_SAMPLE_LIT_PATH);
	float3 p = viewPos + (viewDir * ds) * 0.5;
	const float3 sunLuminance = atmosphere.sun_light_color * atmosphere.sun_light_intensity;
	float3 opticalDepth = float3(0.0, 0.0, 0.0);

	float3 groundColor = float3(0.0, 0.0, 0.0);

	if (distancePlanet > 0.0)
	{
		const float3 groundPos = viewPos + viewDir * distancePlanet;
		const float3 groundNormal = float3(0.0, 1.0, 0.0);
		const float3 sunLuminanceToGround = sunLuminance * TransmitToAtmosphereLut(atmosphere, groundPos, lightDir, _TransmittanceReadonlyLUT, linear_clamp_sampler);
		groundColor = atmosphere.ground_tint * INV_PI * sunLuminanceToGround * saturate(dot(groundNormal, lightDir)) * 0.05;
	}

	for (int i = 0; i < NUM_SAMPLE_LIT_PATH; i++)
	{
		float h = length(p) - atmosphere.planet_radius;
		float3 sigmaS = RayleighCoefficient(atmosphere, h) + MieCoefficient(atmosphere, h);
		float3 sigmaA = OzoneAbsorption(atmosphere, h) + MieAbsorption(atmosphere, h);
		float3 sigmaT = sigmaS + sigmaA;
		opticalDepth += sigmaT * ds;
		
		float3 t1 = TransmitToAtmosphereLut(atmosphere, p, lightDir, _TransmittanceReadonlyLUT, linear_clamp_sampler);
		float3 s = Scattering(atmosphere, p, lightDir, viewDir);
		float3 t2 = exp(-opticalDepth);
		
		float3 inScattering = t1 * s * t2 * ds * sunLuminance;
		color += inScattering;

		float3 multiScattering = SampleMultiScatteringLut(atmosphere, p, lightDir, _MultiScatteringReadonlyLUT, linear_clamp_sampler);
		color += multiScattering * t2 * ds * sunLuminance;

		// color += groundColor * t2 * ds;

		p += viewDir * ds;
	}

	color += groundColor;

	return color;
}

[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void ComputeTransmittance(uint3 id : SV_DispatchThreadID)
{
	float dimX;
	float dimY;
	_TransmittanceLUT.GetDimensions(dimX, dimY);
	
	AtmosphereData atmosphereData = GetAtmosphereData();
	float2 uv = (float2(id.x, id.y) + 0.5) / float2(dimX, dimY);

	float innerRadius = atmosphereData.planet_radius;
	float outerRadius = atmosphereData.planet_radius + atmosphereData.atmosphere_height;
	float2 transmittanceData = UvToTransmittanceParameters(uv, innerRadius, outerRadius);

	// float r = transmittance_data.x - atmosphere_data.sea_level + atmosphere_data.planet_radius;
	// float r = max(transmittance_data.x, atmosphere_data.planet_radius + MIN_HEIGHT);
	float r = transmittanceData.x;
	float cosTheta = transmittanceData.y;
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

	float3 viewPos = float3(0.0, r, 0.0);
	float3 viewDir = float3(sinTheta, cosTheta, 0.0);

	int2 clampedId = clamp(int2(id.xy), 0, int2(dimX - 1, dimY - 1));
    float3 transmittance = TransmitToAtmosphere(atmosphereData, viewPos, viewDir);
    _TransmittanceLUT[clampedId] = float4(transmittance, 1.0);
}

[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void ComputeMultiScattering(uint3 id : SV_DispatchThreadID)
{
	float dimX;
	float dimY;
	_MultiScatteringLUT.GetDimensions(dimX, dimY);
	
	AtmosphereData atmosphereData = GetAtmosphereData();
	float2 uv = (float2(id.x, id.y) + 0.5) / float2(dimX, dimY);
	
	float cosTheta = uv.x * 2.0 - 1.0;
	float r = uv.y * atmosphereData.atmosphere_height + atmosphereData.planet_radius;
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
	float3 lightDir = float3(sinTheta, cosTheta, 0.0);
	float3 position = float3(0.0, r, 0.0);

	int2 clampedId = clamp(int2(id.xy), 0, int2(dimX - 1, dimY - 1));
	float3 multiScattering = MultiScattering(atmosphereData, position, lightDir, _TransmittanceReadonlyLUT, linear_clamp_sampler);
	_MultiScatteringLUT[clampedId] = float4(multiScattering, 1.0);
}

[numthreads(NUM_THREADS, NUM_THREADS, 1)]
void ComputeSkyView(uint3 id : SV_DispatchThreadID)
{
	float dimX;
	float dimY;
	_SkyViewLUT.GetDimensions(dimX, dimY);
	
	AtmosphereData atmosphereData = GetAtmosphereData();
	float2 uv = (float2(id.x, id.y) + 0.5) / float2(dimX, dimY);
	float3 viewDir = CompressedUvToViewDirection(uv);
	float3 lightDir = _MainLightPosition.xyz;
	float cameraPos = max(_WorldSpaceCameraPos.y, MIN_HEIGHT);
	float h = cameraPos - atmosphereData.sea_level + atmosphereData.planet_radius;
	float3 viewPos = float3(0.0, h, 0.0);
	float3 color = GetSkyColor(atmosphereData, viewPos, viewDir, lightDir, -1.0);
	color = saturate(color);
	
	int2 clampedId = clamp(int2(id.xy), 0, int2(dimX - 1, dimY - 1));
	_SkyViewLUT[clampedId] = float4(color, 1.0);
}

// ============================================================================
// Ambient Spherical Harmonics Computation
// ============================================================================

// Shared memory for parallel reduction
groupshared float3 gs_SHCoefficients[9][SH_SAMPLE_COUNT];

// Compute SH basis functions for L0-L2 (9 coefficients)
// Using real spherical harmonics with standard normalization
void ComputeSHBasis(float3 dir, out float basis[9])
{
	// L0 band (1 coefficient)
	basis[0] = 0.282095f; // Y_0^0 = 0.5 * sqrt(1/PI)
	
	// L1 band (3 coefficients)
	basis[1] = 0.488603f * dir.y;  // Y_1^-1
	basis[2] = 0.488603f * dir.z;  // Y_1^0
	basis[3] = 0.488603f * dir.x;  // Y_1^1
	
	// L2 band (5 coefficients)
	basis[4] = 1.092548f * dir.x * dir.y;                      // Y_2^-2
	basis[5] = 1.092548f * dir.y * dir.z;                      // Y_2^-1
	basis[6] = 0.315392f * (3.0f * dir.z * dir.z - 1.0f);      // Y_2^0
	basis[7] = 1.092548f * dir.x * dir.z;                      // Y_2^1
	basis[8] = 0.546274f * (dir.x * dir.x - dir.y * dir.y);    // Y_2^2
}

// Sample sky color from SkyView LUT given a world direction
float3 SampleSkyColor(float3 direction)
{
	float2 uv = ViewDirectionToCompressedUv(direction);
	return _SkyViewReadonlyLUT.SampleLevel(linear_clamp_sampler, uv, 0).rgb;
}

[numthreads(SH_SAMPLE_COUNT, 1, 1)]
void ComputeAmbientSH(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
	// Each thread samples one direction from the predefined sphere samples
	float3 sampleDir = RANDOM_SPHERE_SAMPLES[groupIndex];
	
	// Sample sky color for this direction
	float3 skyColor = SampleSkyColor(sampleDir);
	
	// Compute SH basis for this direction
	float shBasis[9];
	ComputeSHBasis(sampleDir, shBasis);
	
	// Weight for Monte Carlo integration: 4*PI / N (solid angle per sample)
	float weight = 4.0f * PI / (float)SH_SAMPLE_COUNT;
	
	// Store weighted contribution to shared memory
	[unroll]
	for (int i = 0; i < 9; i++)
	{
		gs_SHCoefficients[i][groupIndex] = skyColor * shBasis[i] * weight;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	// Parallel reduction to sum all contributions
	// Only first 32 threads participate in reduction
	[unroll]
	for (uint stride = SH_SAMPLE_COUNT / 2; stride > 0; stride >>= 1)
	{
		if (groupIndex < stride)
		{
			[unroll]
			for (int j = 0; j < 9; j++)
			{
				gs_SHCoefficients[j][groupIndex] += gs_SHCoefficients[j][groupIndex + stride];
			}
		}
		GroupMemoryBarrierWithGroupSync();
	}
	
	// Thread 0 writes final results to output buffer
	if (groupIndex == 0)
	{
		[unroll]
		for (int k = 0; k < 9; k++)
		{
			_AmbientSHCoefficients[k] = float4(gs_SHCoefficients[k][0], 1.0f);
		}
	}
}
